\documentclass[10pt,final]{beamer}
\mode<presentation>
\usetheme{debian}

\ifdefined\knitrout
  \renewenvironment{knitrout}{\begin{footnotesize}}{\end{footnotesize}}
\else
\fi

\usepackage{ulem}
\usepackage{amsmath}
\usepackage{url}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}

\lstloadlanguages{R}
\lstdefinelanguage{Renhanced}[]{R}{
  morekeywords={acf,ar,arima,arima.sim,colMeans,colSums,is.na,is.null,
    mapply,ms,na.rm,nlmin,replicate,row.names,rowMeans,rowSums,seasonal,
    sys.time,system.time,ts.plot,which.max,which.min},
  deletekeywords={Call,socket},
  alsoletter={.\%},
  alsoother={:_\$}}
\lstset{language=Renhanced,
  extendedchars=false,
  %basicstyle=\small\ttfamily,
  basicstyle=\ttfamily\scriptsize,
  commentstyle=\textsl,
  showstringspaces=false,
  %stringstyle=\color{red},
  %keywordstyle=\color{blue},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=3pt,
  breaklines=true,
  index=[1][keywords]}


\hypersetup{pdftitle={Distributed Computing Tutorial},bookmarks}
\title{Distributed Computing Patterns in R}
\date{May 17, 2013}

\author[]{Whit Armstrong\\{\small\texttt{armstrong.whit@gmail.com}}}
\institute{KLS Diversified Asset Management}

<<setup, include=FALSE>>=
opts_chunk$set(size = 'footnotesize')
@ 

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]{Messaging patterns}
  \begin{itemize}
    \item Messaging patterns are ways of combining sockets to communicate effectively
    \item In a messaging pattern each socket has a defined role and fulfills the responsibilities of that role
    \item ZMQ offers several built-in messaging patterns which make it easy to rapidly design a distributed application:
      \begin{itemize}
      \item Request-reply, which connects a set of clients to a set of services.
      \item Pub-sub, which connects a set of publishers to a set of subscribers.
      \item Pipeline, which connects nodes in a fan-out/fan-in pattern that can have multiple steps and loops.
      \item Exclusive pair, which connects two sockets exclusively.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{What does ZMQ give us?}
  \begin{itemize}
  \item ZMQ is like a highly specialized networking toolkit.
  \item It implements the basics of socket communications while letting the user focus on the application.
  \item Very complex messaging patterns can be built on top of these simple ZMQ sockets.
  \item I highly recommend reading ``The Guide'' before writing your own apps.
  \item \url{http://zguide.zeromq.org/page:all} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Request / Reply example}
  \begin{itemize}
  \item Req / Rep is the most basic message pattern.
  \item Both the request socket and reply socket are synchronous.
  \item The reply socket can only service one request at a time, however, many clients may connect to it and queue requests.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Request / Reply, Server}
<<eval=FALSE,echo=TRUE>>=
require(rzmq)

ctx <- init.context()
responder <- init.socket(ctx,"ZMQ_REP")
bind.socket(responder, "tcp://*:5555")

while (1) {
    req <- receive.socket(responder)
    send.socket(responder, "World")
}

@ 
\end{frame}

\begin{frame}[fragile,shrink]{Request / Reply, Client}
<<main-stats-table,echo=TRUE>>=
require(rzmq,quietly=TRUE)

ctx <- init.context()

requester <-  init.socket(ctx,"ZMQ_REQ")

connect.socket(requester, "tcp://localhost:5555")

for(request.number in 1:5) {
    print(paste("Sending Hello", request.number))
    send.socket(requester, "Hello")
    reply <- receive.socket(requester)
    print(paste("Received:",reply,"number",request.number))
}

@ 

\end{frame}

\begin{frame}[fragile]{Pub / Sub example}
  \begin{itemize}
  \item Pub / Sub is a more interesting pattern.
  \item The Pub socket is asynchronous, but the sub socket is synchronous.
  \end{itemize}
\end{frame}

\begin{frame}[fragile,shrink]{Pub / Sub, Server}
<<eval=FALSE,echo=TRUE>>=
require(rzmq)

context = init.context()
pub.socket = init.socket(context,"ZMQ_PUB")
bind.socket(pub.socket,"tcp://*:5556")

node.names <- c("2yr","5yr","10yr")
usd.base.curve <- structure(rep(2,length(node.names)),names=node.names)
eur.base.curve <- structure(rep(1,length(node.names)),names=node.names)

while(1) {
    ## updates to USD swaps
    new.usd.curve <- usd.base.curve + rnorm(length(usd.base.curve))/100
    send.raw.string(pub.socket,"USD-SWAPS",send.more=TRUE)
    send.socket(pub.socket,new.usd.curve)

    ## updates to EUR swaps
    new.eur.curve <- eur.base.curve + rnorm(length(eur.base.curve))/100
    send.raw.string(pub.socket,"EUR-SWAPS",send.more=TRUE)
    send.socket(pub.socket,new.eur.curve)
}

@ 
\end{frame}

\begin{frame}[fragile,shrink]{Pub / Sub, USD Client}
<<echo=TRUE>>=
require(rzmq,quietly=TRUE)

context = init.context()
subscriber = init.socket(context,"ZMQ_SUB")

connect.socket(subscriber,"tcp://localhost:5556")
topic <- "USD-SWAPS"
subscribe(subscriber,topic)

i <- 0
while(i < 5) {
    ## throw away the topic msg
    res.topic <- receive.string(subscriber)
    if(get.rcvmore(subscriber)) {
        res <- receive.socket(subscriber)
        print(res)
    }
    i <- i + 1
}

@ 

\end{frame}

\begin{frame}[fragile,shrink]{Pub / Sub, EUR Client}
<<echo=TRUE>>=
require(rzmq,quietly=TRUE)

context = init.context()
subscriber = init.socket(context,"ZMQ_SUB")

connect.socket(subscriber,"tcp://localhost:5556")
topic <- "EUR-SWAPS"
subscribe(subscriber,topic)
i <- 0
while(i < 5) {
    ## throw away the topic msg
    res.topic <- receive.string(subscriber)
    if(get.rcvmore(subscriber)) {
        res <- receive.socket(subscriber)
        print(res)
    }
    i <- i + 1
}

@ 
\end{frame}

\begin{frame}[fragile,shrink]{Obligatory  deathstar example}
<<eval=TRUE,echo=TRUE>>=
require(deathstar,quietly=TRUE)

estimatePi <- function(seed) {
    set.seed(seed)
    numDraws <- 1e4
    r <- .5
    x <- runif(numDraws, min=-r, max=r)
    y <- runif(numDraws, min=-r, max=r)
    inCircle <- ifelse( (x^2 + y^2)^.5 < r , 1, 0)
    sum(inCircle) / length(inCircle) * 4
}

cluster <- c("localhost")
run.time <-
    system.time(ans <-
                zmq.cluster.lapply(cluster=cluster,
                                   as.list(1:1e3),
                                   estimatePi))

print(mean(unlist(ans)))
print(run.time)
print(attr(ans,"execution.report"))

@
\end{frame}

\begin{frame}[fragile,shrink]{doDeathstar foreach example}
<<eval=TRUE,echo=TRUE>>=
require(doDeathstar,quietly=TRUE)
registerDoDeathstar("localhost")

z <- foreach(i=1:100) %dopar% {
    set.seed(i)
    numDraws <- 1e4
    r <- .5
    x <- runif(numDraws, min=-r, max=r)
    y <- runif(numDraws, min=-r, max=r)
    inCircle <- ifelse( (x^2 + y^2)^.5 < r , 1, 0)
    sum(inCircle) / length(inCircle) * 4
}

print(mean(unlist(z)))
@ 

\end{frame}


\begin{frame}{Thanks for listening!}
    Many people contributed ideas and helped debug work in progress as the rzmq package was being developed.\\
    \medskip
    Bryan Lewis for collaborating and planning this talk with me.\\
    Kurt Hornik for putting up with my packaging.\\
    John Laing for finding bugs in my code.\\
    Prof Brian Ripley for just being himself.\\
\end{frame}

\end{document}
